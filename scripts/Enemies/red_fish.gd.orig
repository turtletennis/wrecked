extends Fish

class_name RedFish

# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	if targetNodes.size() < 1:
		push_error("Enemy target Node array is empty!")
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
func _physics_process(delta: float) -> void:
	if state == State.WANDERING:
		if (position.distance_squared_to(targetNodes[nextTarget].position) <= 0.01): # 0.1^2
			nextTarget += 1
			if nextTarget > (targetNodes.size() - 1):
				nextTarget = 0
		var target = targetNodes[nextTarget].position
		go_towards_target(target, wanderingSpeed, delta)
		if check_for_player_nearby(playerDetectionRadius):
			change_state(State.CHASING)
	elif state == State.CHASING:
		go_towards_target(player.position, playerChaseSpeed, delta)
		if !check_for_player_nearby(playerIgnoreRadius):
			change_state(State.WANDERING)
	else:
		push_error("Enemy state unimplemented! State: ", State.keys()[state])
<<<<<<< HEAD

func change_state(newState: State):
	print_debug("Changing Enemy state from ", State.keys()[state], " to ", State.keys()[newState])
	state = newState

func go_towards_target(target: Vector3, speed: float, delta: float) -> void:
	var to_target := target - global_position
	to_target.z = 0.0
	if to_target.length_squared() < 0.0001:
		return

	var desired_dir := to_target.normalized()

	# --- Compute steering direction ---
	var velocity_dir := forward_dir
	if velocity.length_squared() > 0.0001:
		velocity_dir = velocity.normalized()

	var steering_dir := velocity_dir.lerp(desired_dir, steering_bias).normalized()

	# --- Turn ONCE toward steering direction ---
	forward_dir = forward_dir.slerp(steering_dir, turn_rate * delta)
	forward_dir.z = 0.0
	forward_dir = forward_dir.normalized()

	# --- Accelerate along forward ---
	var desired_velocity := forward_dir * speed
	velocity = velocity.move_toward(desired_velocity, acceleration * delta)
	velocity.z = 0.0

	# --- Lateral drag (kills ice) ---
	var lateral := velocity - velocity.project(forward_dir)
	velocity -= lateral * lateral_drag * delta

	# --- Fish wiggle ---
	wiggle_time += delta

	# Sideways relative to facing (planar)
	var side := forward_dir.cross(Vector3.UP).cross(forward_dir).normalized()

	# Speed-based strength (0 when stopped)
	var speed_factor := clampf(velocity.length() * wiggle_speed_scale, 0.0, 1.0)

	# Sinusoidal lateral offset
	var wiggle := side * sin(wiggle_time * wiggle_frequency) * wiggle_amplitude * speed_factor

	velocity += wiggle
	velocity.z = 0.0


	# --- Move ---
	var collision = move_and_collide(velocity * delta)
	handle_collision(collision)

	# --- Face forward ---
	look_at(global_position + forward_dir, Vector3.UP)

func check_for_player_nearby(detectionRadius):
	if GameController.player_in_air: return false
	return player.position.distance_to(position) <= detectionRadius

func handle_collision(collision:KinematicCollision3D):
	if (collision):
		var collider = collision.get_collider()
		if (collider is Player):
			var player = collider as Player
			player.push(velocity * pushing_power)
=======
>>>>>>> f42322d0f11dbc2d03a3f1b2d5ad80d3024731fe
